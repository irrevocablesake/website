I"D’<h1 id="dfs-gradient-themed-maze-generator">DFS Gradient Themed Maze Generator</h1>
<hr class="separator" />

<p><img class="bigImage" src="/assets/images/series/maze-generator/ep1/main_gif.gif" /></p>

<p>Mazes, mazes, and mazes are fun to solve, easy but require attention and patience, and more than that they are a good way of passing time. You can draw one right now, but it‚Äôs going to take a few minutes.</p>

<p>Today, we are going to learn how to automate the process of maze generation, we will learn to design an algorithm called ‚Äú<strong>DFS - Depth First Search</strong>‚Äù, lots of fancy terms in there, which is quite simple but generates pretty mazes, the visualization is fun to look at too and we will also look under the hood of the algorithm to get a good grasp on it‚Äôs working.</p>

<p>We will be designing an application in <strong>C++</strong> and <strong>SFML</strong>, with tons of customizable features like fps controls, different modes and tons of other things. And we will also learn an interesting way to present those plain black on white mazes to something more lively like a <strong>Gradient Maze</strong>. So, without any further ado, Let‚Äôs Go!</p>

<p>This tutorial is going to be divided into <b>four</b> sections :</p>

<ul>
  <li>
    <p><b>Analogy</b>: Understanding through a real-life example</p>
  </li>
  <li>
    <p><b>Algorithms</b>: Overall working of the algorithm</p>
  </li>
  <li>
    <p><b>Intuition</b>: In-depth working of the algorithm</p>
  </li>
  <li>
    <p><b>Programming</b>: Programming the Maze Generator</p>
  </li>
</ul>

<p>Feel free to skip around!</p>

<p><i><b>Author‚Äôs Note: </b>Many people would say that there are better algorithms out there for generating mazes, and yes it‚Äôs true. But I treated this as a learning opportunity, and even to come to a conclusion that why other algorithms perform better than this, one should know what this algorithm does, that makes it unworthy! of using it in different situations.</i></p>

<p>Hope you enjoy the read!</p>

<h2 id="analogy">Analogy</h2>
<hr class="separator" />

<p>Before we start with all of that Mathyy / Programming intensive stuff, let‚Äôs try to get an analogy in here.</p>

<p>‚Äù <em>Imagine that you are in a maze, you are exactly at the start of the maze and want to reach the end of the maze. Since you don‚Äôt know the structure of the maze, chances are that you are randomly going to choose a path and follow it. And if that path leads you to a dead-end, instead of just standing there, you might just retrace your steps back up to the last intersection that you encountered. And if that intersection has any paths that you haven‚Äôt visited yet, you would visit those, if they help you reach the endpoint then well and good, else you just return to the intersection. Once you have tried out all of the possible paths from that intersection, only to find out that none of those lead to the exit of the maze, chances are you would retrace and move to some other intersection, in your already transversed path, and see if it has any path that you haven‚Äôt visited yet. And you would keep doing this over and over for every intersection until you find a path.</em> ‚Äú</p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/hit_dead_end.png" /></div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/retraced_dead_end.png" /></div>
</div>

<p><br style="clear:both" /></p>

<p>If we restate the above analogy in a slightly more computeristic language, we would get something like this, a program made for solving mazes would start at a position, and every time it moves to a certain maze cell, it would mark it as visited and store it in the memory, but just in case if the path it is following leads to a dead end it will just retrace the maze cells, stored in its memory, and removing them from its memory at the same time, until it finds the last intersection it encountered, in its already transversed path, and if at that intersection, there is any path that it has not transversed yet, then it would follow that path, else it would return to the intersection before this one and do the same thing until it finds the solution.</p>

<p>And this is exactly the basis of two algorithms called <strong>DFS - Depth First Search</strong> and <strong>Backtracking</strong>. In the next sections, we will have a look at the algorithms.</p>

<h2 id="algorithms">Algorithms</h2>
<hr class="separator" />

<h3 id="what-is-depth-first-search-aka-dfs">What is Depth First Search a.k.a DFS?</h3>

<p>Depth First Search is a method that is largely related to <b>Tree</b> and <b>Graph Data Structures</b>. It is a kind of transversal method where one starts at a parent node goes down through the vertices/children nodes until it hits a dead-end, once it hits a dead end it starts retracing back up to the point where it finds that a certain node in its already transversed path has other unvisited nodes.</p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_first.png" /></div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_second.png" /></div>
</div>

<p><br style="clear:both" /></p>

<h3 id="what-is-backtracking">What is Backtracking?</h3>

<p>A lot of people get confused, with DFS and Backtracking, so before going deep in with the explanations, let‚Äôs learn what backtracking is.</p>

<p>Backtracking is a method, one can say that it‚Äôs a special case of DFS, where we check for certain constraints early on, hence making the program efficient and faster, in which one can find many or some of the possible solutions for a certain problem. It works by building up solutions that might lead to our final answer and if at any stage it finds that a certain solution won‚Äôt lead to a final answer then it abandons it, without trying any further for the current possible solution.</p>

<h3 id="what-is-the-difference-between-dfs-and-backtracking">What is the difference between DFS and Backtracking?</h3>

<p>Backtracking is more like a special case of DFS, which works out by ruling out the situations, early on, that won‚Äôt yield a result, while in the situation DFS, won‚Äôt check for the constraints and keep moving forward.</p>

<p>Let‚Äôs imagine this difference in terms of solving <b>Sudoku grids</b>. DFS in this case would be like a crazy maniac who would keep filling all of the squares completely and at the end, if it does not find the solution, then it would discard it entirely and start with some other solution.</p>

<p>While Backtracking would work smartly by placing some constraint in place, like at each stage, when it fills a number, it would check if the state of the grid is still valid or not, if it is then, it will move on to the next unfilled cell but if it‚Äôs not then it would discard that solution since that won‚Äôt lead to the answer.</p>

<p>In a nutshell, backtracking works by placing some constraints in place and not working like a crazy maniac.</p>

<h3 id="why-are-we-discussing-maze-solving">Why are we discussing maze solving?</h3>

<p>Well, it turns out the way <b>DFS</b> works, it can be used for both solving and creating mazes, the only difference being that instead of having a pre-made maze, we would start with a grid full of cells and borders, and then every time we move from one cell to another we just erase the walls between the two cells, let‚Äôs not get too ahead of our selves, we will have a look at this afterward.</p>

<h3 id="dfs-algorithm">DFS algorithm</h3>

<ul>
  <li>
    <p>Choose the initial cell, mark it as visited, and push it to the stack</p>
  </li>
  <li>
    <p>While the stack is not empty</p>

    <ul>
      <li>
        <p>Pop a cell from the stack and make it a current cell</p>
      </li>
      <li>
        <p>If the current cell has any neighbors  which have not been visited</p>

        <ul>
          <li>
            <p>Push the current cell to the stack</p>
          </li>
          <li>
            <p>Choose one of the unvisited neighbors</p>
          </li>
          <li>
            <p>Mark the chosen cell as visited and push it to the stack</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="maze-generation-algorithm">Maze Generation Algorithm</h3>

<p>Maze Generation is one of the applications of the DFS algorithm, here we randomly choose the next node, to be visited, and every time we randomly choose a neighbors, we just remove the walls between the two nodes and hence eventually caving through and generating a maze.</p>

<ul>
  <li>
    <p>Choose the initial cell, mark it as visited, and push it to the stack</p>
  </li>
  <li>
    <p>While the stack is not empty</p>

    <ul>
      <li>
        <p>Pop a cell from the stack and make it a current cell</p>
      </li>
      <li>
        <p>If the current cell has any neighbors  which have not been visited</p>

        <ul>
          <li>
            <p>Push the current cell to the stack</p>
          </li>
          <li>
            <p>Choose one of the unvisited neighbors</p>
          </li>
          <li>
            <p>Remove the wall between the current cell and the chosen cell</p>
          </li>
          <li>
            <p>Mark the chosen cell as visited and push it to the stack</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="intuition">Intuition</h2>
<hr class="separator" />

<p>Now that we know what Algorithms mean, let‚Äôs try to build a small intuition for their working as to how they work and transverse through a graph/tree. And then we will see how we can use the same thing for producing mazes.</p>

<h3 id="assumptions">Assumptions</h3>

<p>Before we start with the explanations, to make things easier let‚Äôs place a few assumptions in place :</p>

<ul>
  <li>
    <p>If we carefully look at the maze we can say that a maze can be easily represented as a graph were every maze cell would be an equivalent to a graph node.</p>
  </li>
  <li>
    <p>We assume that the dimensions of the maze are 3x3.</p>
  </li>
  <li>
    <p>To remember the visited cells, we are going to store it into a stack, we choose a stack cause it‚Äôs mechanism makes it easier for us to retrace back.</p>
  </li>
  <li>
    <p>We also assume that the graph is unweighted and undirected.</p>
  </li>
</ul>

<h3 id="step-wise-understanding-of-dfs-algorithm">Step Wise understanding of DFS Algorithm</h3>
<p><br /></p>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/labelled.png" /></div>
<div class="rightText"><p><b>Step 1</b><br /><br />Just to get familiar with graphs, here is a simple 3x3 graph with the nodes represented as grey colored boxes where each node is connected to some other node using blue lines, also called <b>Edges</b>.<br /><br />We are also going to represent different states of nodes using colors<br />
<ul>
    <li><b>Non visited node</b>: Colourless</li>
    <li><b>Visited node</b>: Green color</li>
    <li><b>Current node</b>: Orange color</li>
    <li><b>Possible neighbors</b>: Blue color</li>
</ul>
</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide1.png" /></div>
<div class="leftText"><p><b>Step 2</b><br /><br />This is the initial state of the graph where we haven't visited any of the nodes yet.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide2.png" /></div>
<div class="rightText"><p><b>Step 3</b><br /><br />We start our journey of transversal, at the top left corner of the graph, we mark the node 1 as visited, push it to the stack, and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide3.png" /></div>
<div class="leftText"><p><b>Step 4</b><br /><br />Now it's time to choose the next node, our current node has two possible neighbors, those are node 2 and node 4, which are represented by blue color. We can choose any one of the possible neighbors randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide4.png" /></div>
<div class="rightText"><p><b>Step 5</b><br /><br />We chose the node 2 as the next node, so we moved from node 1 to node 2, marked it as visited, pushed it to the stack, and made it our current cell</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide5.png" /></div>
<div class="leftText"><p><b>Step 6</b><br /><br />Now, we are currently at node 2, we check the possible neighbors that node 2 has. The node 2, has two possible neighbors, node 3 and node 5. We can choose any one of those neighbors randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide6.png" /></div>
<div class="rightText"><p><b>Step 7</b><br /><br />Here we just randomly chose node 5 as our next node and hence we marked it as visited, pushed it to stack, and made it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide7.png" /></div>
<div class="leftText"><p><b>Step 8</b><br /><br />Here we check the possible neighbors for node 5, our current node, and it has 3 possible neighbors, node 6, node 4, and node 8. We can choose any one of the possible neighbors randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide8.png" /></div>
<div class="rightText"><p><b>Step 9</b><br /><br />We chose node 8 as the next node, and hence we marked it as visited, pushed it to the stack, and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide9.png" /></div>
<div class="leftText"><p><b>Step 10</b><br /><br />Here we check the possible neighbours for node 8, it has 2 possible neighbors, node 9 and node 7.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide10.png" /></div>
<div class="rightText"><p><b>Step 11</b><br /><br />We randomly choose node 7 as the next node and we marked it as visited, pushed it to the stack, and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide11.png" /></div>
<div class="leftText"><p><b>Step 12</b><br /><br />We check the possible neighbors for node 7 and it turns out that it has only one neighbor node, node 4.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide12.png" /></div>
<div class="rightText"><p><b>Step 13</b><br /><br />Since we don't have any other option we chose node 4, marked it as visited, pushed it to stack, and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide13.png" /></div>
<div class="leftText"><p><b>Step 14</b><br /><br />Now, here is the thing, we previously were at node 4, and it did not have any unvisited neighbors, which is just like a dead-end, so instead of just stopping there, we retrace our path by popping the 4.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide14.png" /></div>
<div class="rightText"><p><b>Step 15</b><br /><br />We were previously at node 7, it had no unvisited neighbors, which is again like a dead end so, instead of just standing there we just retrace back by popping the node 7.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide15.png" /></div>
<div class="leftText"><p><b>Step 16</b><br /><br />We check the possible neighbors for node 8 and it has 1 possible node that is node 9 that has not been visited yet.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide16.png" /></div>
<div class="rightText"><p><b>Step 17</b><br /><br />In this step we move to that one possible node, node 9, mark it as visited, push it to the stack and make it our current cell</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide17.png" /></div>
<div class="leftText"><p><b>Step 18</b><br /><br />We check the possible neighbors for node 6 and it turns out that this node has one possible neighbor.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide18.png" /></div>
<div class="rightText"><p><b>Step 19</b><br /><br />We move to that one possible neighbor, push it to the stack, mark it as visited , and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide19.png" /></div>
<div class="leftText"><p><b>Step 20</b><br /><br />We check the possible neighbors for the current cell and it turns our this node has only one possible neighbor cell and that is node 3.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide20.png" /></div>
<div class="rightText"><p><b>Step 21</b><br /><br />We mark the only neighbor that is node 3 as visited, push it to the stack, and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide21.png" /></div>
<div class="leftText"><p><b>Step 22</b><br /><br />We could technically stop here, and we know that because we can see that, but the computer does not know that it has transversed everything, in fact it does not understand any of this. So according to the algorithm design, it will keep popping the nodes, and searching for unvisited nodes at each step, and eventually, the stack would become empty. It works this way, so that every node is visited.</p></div>
</div>

<p><br style="clear:both" /></p>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide22.png" /></div>
<div class="rightText"><p><b>Step 23</b><br /><br />And this is the final result. We have visited all of the nodes.</p></div>
</div>

<p><br style="clear:both" /></p>

<h3 id="dfs-application-as-maze-generation">DFS Application as Maze Generation</h3>

<p>Now, that we are done with the <b>DFS</b> algorithm, let‚Äôs move to the Maze Generation algorithm. Since, it‚Äôs just an application of the actual DFS algorithm, nothing much changes. Apart from the fact that every time we move from one node to another we just remove the walls between the two nodes. Hence caving through, eventually resulting in a maze.</p>

<p><br style="clear:both" /></p>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_1.png" /></div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_2.png" /></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_3.png" /></div>
<div class="leftText"><br /><br /><br /><p>Here is the final result of implementing the Maze Generation Algorithm.</p></div>
</div>

<p><br style="clear:both" /></p>

<h2 id="programming">Programming</h2>
<hr class="separator" />

<h3 id="optimizations">Optimizations</h3>

<p>We can immediately think that since a maze is a two-dimensional object, that is, a grid and the grid has cells, and all of those cells have similar properties like, if the cell has been visited or not, the list of walls that the cells have, and the coordinates of the cell that we are currently working with, and one might suggest that we can create a <span class="badge badge-dark">Cell</span> class and then create a two-dimensional array out of the cell class.</p>

<p>So we would end up with a class something like this:</p>

<pre><code class="language-cpp">class Cell
{
  	public:
    	int x;
    	int y;
    	
    	bool visited;
    
    	bool walls={true,true,true,true}; // top, right, bottom, left
};</code></pre>

<p>This looks great!</p>

<p>But this is not at all memory efficient, let‚Äôs just throw some numbers in here, to actualize why!, So for a second let‚Äôs imagine that we want to produce a 10k x 10k grid which means the total cells are around: <b>100000000</b>, and we can then create a 2d grid of out of the <span class="badge badge-dark">cell class</span> like this:</p>
<pre><code class="language-cpp">Cell maze[10000][10000];</code></pre>
<p>and if we calculate memory required for one cell object, that will be around: 4 bytes + 4 bytes + 1 byte + 4 bytes, so in total that is around <b>13 bytes</b> for a single cell, and for <b>100000000</b> cells it would be around: <b>1300000000</b> or <b>1.3 GB</b> and that is a ton.</p>

<p>So we need to find a way to reduce the memory consumption for a single cell, which should reduce the overall memory consumption, and this is where  the concept of <b>Bits</b> and <b>Bit masking</b> is extremely useful.</p>

<h4 id="bits">Bits</h4>

<p>A <b>Bit</b> is the smallest unit in the computer world, a single bit can attain only two values either ‚Äú<b>1</b>‚Äù or ‚Äú<b>0</b>‚Äù. If a bit is said to be ‚Äú<b>ON</b>‚Äù then the bit has a value of ‚Äú<b>1</b>‚Äù and if a bit is said to be ‚Äú<b>OFF</b>‚Äù then it is said to have a value of ‚Äú<b>0</b>‚Äù.</p>

<p>Of course, just having sequences of tons of bits is no fun, so to be able to perform operations between different bits we have something called <b>Bitwise Operators</b>.</p>

<h5 id="bitwise-operators-and-operation">Bitwise Operators and Operation</h5>

<p>Bitwise operators are used for playing with bits, that is, if we provide it a decimal number, that is a human-readable value, it‚Äôs gonna take that number and play around with its bits, sounds fun.</p>

<p>We have 6 different bitwise operators, luckily they work exactly like the logical operators.</p>

<pre><code class="language-cpp">&amp;  : This works like the logical AND
|  : This works like the logical OR 
~  : This works like the logical NOT
^  : This works like the logical XOR
&lt;&lt; : This bitwise operator shifts the bits to the left by a certain positions.
&gt;&gt; : This bitwise operator shifts the bits to the right by a certain positions.</code></pre>
<p>and using these bitwise operators we can do tons of useful stuff and optimizations.</p>

<p><b>Note: </b>The number of bits that we get to play around depends upon the size of data type, that is, a <b>char</b> being <b>1 byte</b>, it‚Äôs gonna provide us with <b>8 bits</b> to play around, <b>int</b> being <b>4 bytes</b>, it‚Äôs gonna provide us with <b>32 bits</b> to play around.</p>

<p>The thing is computers do not understand any of this, they are just good at following orders.</p>

<p>Using the bitwise operators is gonna affect the entire sequence of bits, but what if we want to work with a certain bit at a certain position in that sequence of bits. This is where the concept of ‚Äú<b>Bit Masking</b>‚Äù comes in.</p>

<h5 id="bit-masking">Bit Masking</h5>

<p>Just as the name says it works by <b>masking</b>/<b>hiding the bits</b> that we do not wanna work with and <b>exposing</b> only the ones that we wanna work with. Using bitmasks, with the combination of logical operators, would allow us to change the values of the bits, also help us check if a certain bit is ‚Äú<b>ON</b>‚Äù or ‚Äú<b>OFF</b>‚Äù.</p>

<p>A bitmask generally has the following structure, assuming we are talking about <b>8 bits</b>.</p>

<pre><code class="language-cpp">00000001 // we refer to this as the mask</code></pre>
<p>were the bit set to ‚Äú<b>1</b>‚Äù says that ‚Äú <i>hey this is the position we wanna work with</i> ‚Äú meaning it kinda exposes that value to changes and the bits set to ‚Äú<b>0</b>‚Äù kinda masks the values, so none of the changes are applied to it.</p>

<p>To check if a bit is on or off :</p>
<pre><code class="language-cpp">mask = 10000000
value = 11110001

mask &amp; value // this means we want to check if the last bit of the value is set to one or not if it's on then it return 1 else 0, meaning it just performs and operation between the values</code></pre>
<p>To turn a bit on:</p>
<pre><code class="language-cpp">mask = 10000000
value = 00000011

value |= mask // this would perform "OR" operation between the two and store the result into the value.

value = 10000011
</code></pre>
<p>To turn a bit off:</p>
<pre><code class="language-cpp">mask = 10000000
value = 10000101

value &amp;= ~mask; // here we first invert the value of mask so the bits of mask become 01111111 and then we apply the &amp; operator to the value and the inverted mask

value = 00000101</code></pre>

<h3 id="back-to-optimization">Back to Optimization</h3>

<p>Now that we know what <b>Bits</b>, <b>Bits Masks</b> are, and how we can work on a bit level, let‚Äôs start with the optimization procedure.</p>

<p>Let‚Äôs start with the fact that we do not need to store the coordinates of the cell, we can just find out the neighboring cells based on the index of the current cell, and since we are using arrays, we already will be having the index of the current cell. Eliminating the co-ordinates would reduce around <b>8 bytes</b>.</p>

<p>Let‚Äôs have a look the walls since the walls can attain only two values either ‚Äú<b>0</b>‚Äù or ‚Äú<b>1</b>‚Äù, we can directly store them inside a byte as contiguous bits and that goes same with the visited parameter since that too can attain only two values we can also store that with the wall bits.</p>

<p>As we read above the number of bits that we get to play with is decided by the data type and since we only need around <b>5 bits</b> we can choose the smallest data type, which is the ‚Äú<b>unsigned char</b>‚Äù. This would give us around <b>8 bits</b> to play around, which is more than enough we will only use <b>5 bits</b> per cell for storing the properties.</p>

<p>so something like this</p>

<pre><code class="language-cpp">//One can come up with any convention of storing the 5 bits in the unsigned char, we choose the following convention

// unsigned char cell = 0b000V'LBRT
// where the V stands for the visited bit
// and L,B,R,T stand for LEFT, BOTTOM, RIGHT, TOP wall existance bits, respectively

unsigned char cell = 0b0000'1111</code></pre>

<p>Now we can just save the state of a particular cell in under 1 byte.</p>

<p>If it‚Äôs just a single variable using a class for storing it would be overkill, cause we can directly create an array out of a single variable.</p>

<p>something like this:</p>
<pre><code class="language-cpp">unsigned char cell[10000][10000];</code></pre>
<p>let‚Äôs calculate the memory usage for this, so <b>100000000</b> cells <b>1 byte</b> each equals to <b>100000000 bytes</b> which is <b>100mb</b> which is a lot better than the <b>1.3 GB</b> memory usage.</p>

<p>There is another optimization we can do, and that is related to the representation of the maze</p>

<h4 id="representation">Representation</h4>
<p>We want a grid to work with and that can be done using <b>static</b> 2d array / multidimensional array but since static array has scope limitations, we need to use <b>dynamic 2d array</b>. But doing this would cause a lot of <b>fragmented memory</b>, which is bad cause it‚Äôs going to affect the efficiency of our program, cause every new row of the grid would be located at a new location, and to overcome this we can use a <b>dynamic 1d array</b>, we will represent a 2d grid into 1d array :</p>

<pre><code class="language-cpp">
0  1  2  3       
4  5  6  7
8  9  10 11

// normally grid cell can be located by saying that's it's in a particular row and column
//for instance let's say we want to locate element 6, we can say that its in row 1 and column 2

But if we start counting from the first cell till the last cell and assign numbers, just like in the above diagram we can use indexes to locate a cell.

Likewise we can just store the 2d grid as a 1d array by rearraging the original 2d array

0 1 2 3 4 5 6 7 .......11

// we can see here that the index of the first element in the second row is a continuation of the index of the last element of the first row
// if you want to access a particular cell based upon the row and column
//then one can just use the following formula : row * (number of cols) + col
// the index of element 6 in the 1d array would be : 1 * 4 + 2 = 6
// which means that the element 6 is at 6th position in the 1d array. 
</code></pre>
<p>This would give us a few advantages too like caching of memory and a more compact memory and hence a faster program.</p>

<p>This should be enough optimizations for the program and we can start now.</p>

<h3 id="gradient">Gradient</h3>

<p>The gradient that we are using here, is called <b>linear Interpolation</b>. The way this works is, we start with 100% of color one and 0% of color two, then at every new row, we just reduce the percentage of color one by a constant amount, and increase the percent of color two by the same constant amount.</p>

<p>To be able to have the gradient spread all over the maze from top to bottom, we determine the value of that ‚Äú<b>constant amount</b>‚Äù by dividing the initial percent by the number of rows</p>

<p>The mathematical version of this is :</p>

<pre><code class="language-cpp">float initial = 1;
float p = initial;

go through each row:
    for each cell in the row:
        paint it with : ( color one * p ) + ( color two * ( 1 - p ) );
    once done with a row, we update the value of p, as mentioned above.
    p = p - ( ( initial / total_rows ) );


// for a grid of 3 x 3 it would look like this
// all cells in row 1 would be : 100% color one and 0% color two
// all cells in row 2 would be : 67% color one and 33% color two
// all cells in row 3 would be : 34%% color one and 66% color two
// of course the more the rows the cleaner the gradient
// one can also apply the same method to pixels instead of the cells, to get a beautiful gradient at any dimension.
</code></pre>

<h3 id="file-structure">File Structure</h3>
<p>We are gonna be using the following file strucutre</p>
<pre><code class="language-cpp">//********************Helper****************************
helper.h   
helper.cpp
// generation of random numbers
//*******************************************************

//**************************Masking******************************
masking.h
// holds all of the masks for working with bits
//***************************************************************

//**************************Image Saving**************************
image.h
image.cpp
// contains a function that helps us with the saving of image
//****************************************************************

//**************************Features File*************************    
feature.h
// this file will act as a data holder for all of the features of the maze
//****************************************************************

//**************************Maze**********************************
maze.h
maze.cpp
// this file act as the heart of the program, DFS + Graphics
//****************************************************************
</code></pre>

<h4 id="implementation">Implementation</h4>

<p>Let‚Äôs start with the helper file, the sole purpose of this file is going to be able to help us generate random numbers. The structure of the header file is going to be something like this</p>

<h5 id="helper-file">Helper file</h5>
<pre><code class="language-cpp">class Helper
{
    struct xorshift128p_state
    {
        uint64_t a, b;
    };
    
    public :
        Helper();
        xorshift128p_state state;
        uint64_t xorshift128p(struct xorshift128p_state *state);
};</code></pre>

<p>and the corresponding file for all of the method bodies is going to be something like this :</p>

<pre><code class="language-cpp">Helper::Helper()
{
	srand(time(NULL));
	state.a=rand();
	state.b=rand();
}

uint64_t Helper::xorshift128p(struct xorshift128p_state *state)
{
	uint64_t t = state-&gt;a;
	uint64_t const s = state-&gt;b;
	state-&gt;a = s;
	t ^= t &lt;&lt; 23;		// a
	t ^= t &gt;&gt; 17;		// b
	t ^= s ^ (s &gt;&gt; 26);	// c
	state-&gt;b = t;
	return (t + s);
}</code></pre>

<p>The way this file works is that as soon as we create an <b>object</b> of the <span class="badge badge-dark">class Helper</span>, it invokes the <b>constructor</b> which then randomizes the states/input values of the random number generator. Then every time we want to generate a random number, we just have to call the <span class="badge badge-dark">xorshift128p()</span> and we just have to pass those states to that function, then that function generates a random value based upon the passed states/input values, with the help of bitwise operations, and it updates the old state with new values.</p>

<p>So, in a nutshell, this works by producing random values based upon states, and since using the same states would produce the same random number, it just re-populates the old states with some kind of new value and uses those new states for producing another new random number, this updating of states occurs every time we call the <span class="badge badge-dark">xorshift128p()</span>.</p>

<p>Now let‚Äôs start with another file called the <b>Features</b> file. The sole purpose of this file is going to be holding all of the necessary data regarding the <b>dimensions and appearance</b> of the maze, so just in case if we need to use the data regarding anything related to <b>dimensions/appearance</b>, we will be able to access it in one place.</p>

<h5 id="features-file">Features file</h5>

<pre><code class="language-cpp">struct Feature
{
    int width;
    int height;
    int rows;
    int cols;
    int cellSize;
    int fps;
    int animate;

    sf::Color borderColor;
    sf::Color backgroundColor;
    sf::Color start;
    sf::Color end;
    sf::Color visitedColor;
    sf::Color notVisitedColor;
    sf::Color currentColor;
};</code></pre>

<p>To use this, we just have to declare an object of this structure and then we can access the various properties, just like in the following example</p>

<pre><code class="language-cpp">Feature feature;
feature.width=500;
feature.height=500;
.
.
.</code></pre>

<p>As mentioned in the above <b>optimization sections</b>, working at a bit level is going to help us make our application efficient. So we are going to use all of the concepts that we discussed in the said section.</p>

<p>We are going to create a file called masking which will hold all of the data related to the masks for using them with bits.</p>

<h5 id="masking-file">Masking File</h5>
<pre><code class="language-cpp">const unsigned char topMask = 0b0000'0001;
const unsigned char rightMask = 0b0000'0010;
const unsigned char bottomMask = 0b0000'0100;
const unsigned char leftMask = 0b0000'1000;
const unsigned char visitedMask = 0b0001'0000;</code></pre>

<p>We are also going to create a file called image, that will help us with the saving of image, given that we pass it the array of type <b>unsigned char</b> with binary values. But since this tutorial is about maze generation and not about maze saving, we are not going to discuss it here, but you can find the code for the function on the Github.</p>

<p>Now, it‚Äôs time to create the most important file, that is the <b>heart</b> of the program.</p>

<p>This file is divided into 4 sections :</p>
<ul>
  <li>The first section sets the user-defined features to the maze.</li>
  <li>The second section uses the DFS algorithm to generate mazes.</li>
  <li>The third section generates graphics if needed.</li>
  <li>The fourth section acts as a control for calling various functions.</li>
</ul>

<p>Something like this :</p>

<h5 id="maze-file">Maze File</h5>
<pre><code class="language-cpp">enum Mode
{
    ANIMATE=1,
    IMAGE=-1,
    DISPLAY=0,
};

class Maze
{
    private:
        vector&lt;unsigned char&gt; maze;
        vector&lt;int&gt; backtrack;

        Feature f;
        Helper helper;
        Image image;
        
    public:
        void setFeatures(const Feature &amp;feature); // this functions sets the user defined features to the maze
        void createMaze(string windowName);
   
    private:  
       
        //******************************DFS Section******************************
        void checkNeighbour(int current);
        void dfsBacktrack();
        //***********************************************************************

        //******************************Graphics Section*************************
        void drawWindow(sf::RenderWindow &amp;window, string windowName);
        void handleBorder(int borderCounter,int x,int y,int value);
        void createVertexArray(int explicitCheck=-1);
        //***********************************************************************

        //******************************Image Saving*****************************
        void saveAsImage();
        //***********************************************************************

        //******************************Main Control*****************************
        void initialize(); // + createMaze(string windowName)
        //***********************************************************************
};</code></pre>

<p>The first function here that will be called is the <span class="badge badge-dark">setFeatures()</span>, this function would receive the feature object that the <b>user</b> has <b>populated</b> and it will set the features to the maze.</p>

<pre><code class="language-cpp">void Maze::setFeatures(const Feature &amp;feature)
{
    f=feature;
    f.rows=f.height/f.cellSize;
    f.cols=f.width/f.cellSize;
}</code></pre>

<p>Then the next function that the user will call is the <span class="badge badge-dark">createMaze()</span></p>

<pre><code class="language-cpp">void Maze::createMaze(string windowName)
{
    initialize();

    maze[0] |= visitedMask; 
    backtrack.push_back(0);

    externalLimit=(f.rows*f.cols)-1;

    if(f.animate==IMAGE)
    {   
        dfsBacktrack(); 
        image.saveImage("love_testing.png",maze,f);
    }
    else if(f.animate==DISPLAY)
    {
        sf::RenderWindow window;
        dfsBacktrack();
        createVertexArray(1);
        drawWindow(window,windowName);
        image.saveImage("love_testing.png",maze,f);
    }
    else if(f.animate==ANIMATE)
    {
        sf::RenderWindow window;
        createVertexArray(1);
        drawWindow(window,windowName);
        image.saveImage("love_testing.png",maze,f);
    }

    maze.clear();
    vector&lt;unsigned char&gt;().swap(maze);
}</code></pre>

<p>This function would then in turn called another function called <span class="badge badge-dark">initialiaze()</span>, this initialize function would then resize all of the necessary containers.</p>

<pre><code class="language-cpp"> try 
{
    unsigned char initial=0b0000'1111;
    maze.resize(f.rows*f.cols,initial); // this is the maze data holder
}
catch (const std::bad_alloc&amp;)
{
    cout&lt;&lt;"error in initializing the array";
}

if(f.animate!=IMAGE)
{
    quad.setPrimitiveType(sf::Quads);   // this is related to graphics
    border.setPrimitiveType(sf::Lines); // this is related to graphics

    quad.resize(4*f.rows*f.cols);       // this is related to graphics
    border.resize(8*f.rows*f.cols);     // this is related to graphics
}</code></pre>

<p>Once the <span class="badge badge-dark">initialize()</span> is done executing, we resume the <span class="badge badge-dark">createMaze()</span>, it then marks a starting point for transversal, here we choose the first cell as the starting point using the following statements</p>

<pre><code class="language-cpp">maze[0] |= visitedMask; // we marked it as visited by turning the visited bit on using bitwise operators
backtrack.push_back(0); // we make a note of it by pushing it to the stack.</code></pre>

<p>Now let‚Äôs talk about the <span class="badge badge-dark">dfs()</span>, we‚Äôll have a look at the various modes later.</p>

<pre><code class="language-cpp">void Maze::dfsBacktrack()
{
    if(f.mode!=ANIMATE)
    {
        int current;
         
        while(!backtrack.empty())
        {
            current=backtrack.back();
            backtrack.pop_back();
           
            checkNeighbour(current);
        
        }
    }
    else if(f.mode==ANIMATE &amp;&amp; !backtrack.empty())
    {
        int current=backtrack.back();
        backtrack.pop_back();

        checkNeighbour(current);
    }
}</code></pre>

<p>This function first checks what mode is currently set, if it‚Äôs <b>not</b> animation, it just performs the entire dfs algorithm, in <b>one step</b> and updates the maze data holder accordingly. At each <b>iteration</b> of the algorithm it checks if the stack, that it is using, to store the transversed path, is empty or not, if it is empty it just stops the operation, else if it‚Äôs not it pops the last pushed node and passes it to the check neighbor  function.</p>

<p>The <span class="badge badge-dark">checkNeighbour()</span>, then check if the passed node has any neighbor that has not been visited yet, if it does, then it makes a list of all such neighbors and chooses a <b>random</b> neighbor and pushes the current node back to the stack and the next randomly chosen neighbor. If it does not find any neighbor then it just does nothing.</p>

<p>Let‚Äôs pause here for a second and have a look at how it smartly retraces back. If the current node does not have any neighbors, then it should be automatically removed from the stack and the previous node should be examined, just as we saw in the intuition, and this is exactly what the function does, it before calling the function it first pops the current node and only pushes it back if it has any unvisited nodes else it does not, which is kind of like an automatic retracing.</p>

<p>and this is how the mode IMAGE works, it calls the <span class="badge badge-dark">dfs()</span> and since the mode is set to IMAGE, which means it‚Äôs not animate mode, it performs the entire dfs algorithm in one step and then we call and pass the maze, data holder, to the imagesave(), which then proceeds to save the image as a <b>png file</b>.</p>

<p>Now let‚Äôs talk about mode DISPLAY, this one works exactly like mode IMAGE, except for the fact that we also need to display the maze graphically on the screen. So, in this case, we just call two extra functions called <span class="badge badge-dark">createVertexArray()</span> and <span class="badge badge-dark">drawWindow()</span>, what these functions do is first the <span class="badge badge-dark">createvertexarray()</span> converts the maze data, that is the maze generated by the dfs algorithm, to graphical data through vertex Arrays and the <span class="badge badge-dark">drawWindow()</span> keeps drawing the created vertex array on the screen.</p>

<pre><code class="language-cpp">void Maze::createVertexArray(int explicitCheck)
{
    if(explicitCheck==1)
    {
        for(int i=0;i&lt;f.rows;i++)
        {
            for(int j=0;j&lt;f.cols;j++)
            {
                firstCalcx=(j*f.cellSize)+padding;
                firstCalcy=(i*f.cellSize)+f.cellSize+padding;
                secondCalcx=j*f.cellSize+padding;
                secondCalcy=i*f.cellSize+padding;
                thirdCalcx=(j*f.cellSize)+f.cellSize+padding;
              
                quad[counter].position.x=firstCalcx;
                quad[counter].position.y=firstCalcy;
                ..

                border[borderCounter].position.x=secondCalcx;
                border[borderCounter].position.y=secondCalcy;
                ..

                int visited=maze[(f.cols*i)+j] &amp; visitedMask;
                if(!visited)
                {   
                    quad[counter].color = f.notVisitedColor;
                    quad[counter+1].color = f.notVisitedColor;
                    quad[counter+2].color =f.notVisitedColor;
                    quad[counter+3].color =f.notVisitedColor;
                }
                else
                {
                   
                    quadColor.r=(f.start.r*p)+(f.end.r*(1-p));
                    quadColor.g=(f.start.g*p)+(f.end.g*(1-p));
                    quadColor.b=(f.start.b*p)+(f.end.b*(1-p));

                    quad[counter].color = quadColor;
                    quad[counter+1].color = quadColor;
                    quad[counter+2].color = quadColor;
                    quad[counter+3].color =quadColor;
                }
  
                handleBorder(borderCounter,i,j,-1);
            
                counter=counter+4;
                borderCounter=borderCounter+8;
            }
            p=p-((initial/f.rows));
        }
    }
    else
    {
        if(!backtrack.empty())
        {
            float first=initial-(int(backtrack.back()/f.cols)) * (initial/f.rows);
            float second=1 - first;
 
            quadColor.r=(f.start.r*first)+(f.end.r*second);
            quadColor.g=(f.start.g*first)+(f.end.g*second);
            quadColor.b=(f.start.b*first)+(f.end.b*second);

            quad[(backtrack.back()*4)].color = quadColor;
            quad[(backtrack.back()*4)+1].color = quadColor;
            quad[(backtrack.back()*4)+2].color = quadColor;
            quad[(backtrack.back()*4)+3].color =quadColor;

            if(backtrack.size()&gt;=2)
            {
                handleBorder((backtrack.back()*8),-1,-1,backtrack.back());            
                handleBorder((backtrack[(backtrack.size()-2)]*8),-1,-1,backtrack[(backtrack.size()-2)]);            
            }
        }
    }
}</code></pre>

<p>This function loops through every cell of the maze and converts all of the mathematical data to something graphical and it also checks if the cell is visited or not, if it is then it paints it with the user-defined color else it paints with a mathematically generated gradient between two colors specified by the user, the other thing it does that for each cell it invokes a function called <span class="badge badge-dark">handleborder()</span>, this function checks which of the border exists and which of them don‚Äôt and it paints the border with user-specified border color and transparent color respectively.</p>

<p>This is the <span class="badge badge-dark">handleborder()</span></p>

<pre><code class="language-cpp">void Maze::handleBorder(int borderCounter,int x,int y,int value)
{
    int index;
    if(value&lt;0)
    {
        index=(f.cols*x)+y;
    }
    else
    {
        index=value;
    }
    
    if(maze[index] &amp; topMask)
    {
        border[borderCounter].color = f.borderColor;
        border[borderCounter+1].color = f.borderColor;
    }
    else
    {
        border[borderCounter].color =sf::Color::Transparent;
        border[borderCounter+1].color =sf::Color::Transparent;
    }    
    if(maze[index] &amp; rightMask)
    {
        border[borderCounter+2].color = f.borderColor;
        border[borderCounter+3].color =f.borderColor;
    }
    else
    {
        border[borderCounter+2].color =sf::Color::Transparent;
        border[borderCounter+3].color = sf::Color::Transparent;
    }
    if(maze[index] &amp; bottomMask)
    {
        border[borderCounter+4].color = f.borderColor;
        border[borderCounter+5].color = f.borderColor;
    }
    else
    {
        border[borderCounter+4].color =sf::Color::Transparent;
        border[borderCounter+5].color = sf::Color::Transparent;
    }
    if(maze[index] &amp; leftMask)
    {
        border[borderCounter+6].color = f.borderColor;
        border[borderCounter+7].color = f.borderColor;
    }
    else
    {
        border[borderCounter+6].color = sf::Color::Transparent;
        border[borderCounter+7].color =sf::Color::Transparent;
    }
}</code></pre>

<p>and the <span class="badge badge-dark">drawWindow()</span> looks like this:</p>

<pre><code class="language-cpp">void Maze::drawWindow(sf::RenderWindow &amp;window,string windowName)
{
      int padding=10;
      window.create(sf::VideoMode((f.cols*f.cellSize)+(2*padding),(f.rows*f.cellSize)+(2*padding)),windowName);
      
      if(f.animate)
      {
        window.setFramerateLimit(f.fps);
      }
      
      while(window.isOpen())
      {
          sf::Event event;
          while(window.pollEvent(event))
          {
              if(event.type==sf::Event::Closed)
              {
                  window.close();
              }
          }

          window.clear(f.backgroundColor);

            if(f.animate)
            {
                dfsBacktrack();
                createVertexArray(-1);
                if(!backtrack.empty())
                {
                    quad[(backtrack.back()*4)].color = f.currentColor;
                    quad[(backtrack.back()*4)+1].color = f.currentColor;
                    quad[(backtrack.back()*4)+2].color = f.currentColor;
                    quad[(backtrack.back()*4)+3].color =f.currentColor;
                }
            }        

            window.draw(quad);
            window.draw(border);

            window.display();

        if(f.animate &amp;&amp; !backtrack.empty())
        {
            quad[(backtrack.back()*4)].color = quadColor;
            quad[(backtrack.back()*4)+1].color = quadColor;
            quad[(backtrack.back()*4)+2].color = quadColor;
            quad[(backtrack.back()*4)+3].color =quadColor;
        }
      }
}</code></pre>

<p>It just creates a window and keeps running it until the user closes it, and for each frame, it just keeps drawing the said vertex arrays and as soon as the user hits the close button the said maze vector is passed to the saveimage function which then proceeds to save this mathematical data as a png image.</p>

<p>Now let‚Äôs move to the visualization mode, coding this mode is just a matter of adding a few if-else statements, this works exactly like the mode 0, except for the fact that instead of performing the entire dfs in one step we do it per frame, meaning we call the dfs function every frame, which means the vector maze is being updated every frame which means we also need to update the vertex data for each frame, which can be done by calling the dfs() and createVertexArray() for each frame.</p>

<p>But imagine this the first frame is going to be a grid full of cells, each having all of its walls, and then every frame we just either pop or push either a single cell, which meaning we don‚Äôt have to go through the entire maze and create a new vertex array, instead we can just update the only data that has been changed between the current and the last frame, and this can be done easily by adding an if-else statement in the vertex array and that is the sole purpose of if(explicitcheck==1) in the createVertexArray(), it checks if the mode is a visualization or not if it is then it just updates the only data that has been changed between two frames else if it‚Äôs not it and the dfs() won‚Äôt even be called in the draw window(), since in the other two modes the dfs will be performed in one step and it will be just a matter of displaying it on the user‚Äôs screen.</p>

<p>and finally, this is what the main control for the entire program would look like</p>

<pre><code class="language-cpp">int main()
{
    sf::Color grey(200,200,200);
    sf::Color start(209,59,19);
    sf::Color end(0,25,51);
    
    Feature feature;

    feature.animate=0;
    feature.fps=0;
    feature.width=500;
    feature.height=500;
    feature.cellSize=23;
    feature.backgroundColor=sf::Color::White;
    feature.borderColor=sf::Color::Black;
    feature.currentColor=sf::Color::Red;
    feature.notVisitedColor=grey;
    feature.start=sf::Color::White;
    feature.end=sf::Color::White;

    Maze maze;
    maze.setFeatures(feature);
    maze.createMaze("DFS Backtracking Maze");
  
    return 0;
}</code></pre>

<p>The user has just to populate the feature object and then set the features to the maze and start the process of maze generation through createMaze();</p>

<p>And that is it, this was the entire process of creating a maze generation program with tons of customization features.</p>

<p>To summarize, what we learned :</p>

<ul>
  <li>We first started with an analogy of solving a maze.</li>
  <li>We then stated the analogy in a slightly more computeristic language.</li>
  <li>We then had a look at the important algorithms like DFS, Backtracking.</li>
  <li>We then learned how maze generation is just an application of DFS.</li>
  <li>We then learned about the DFS algorithm in deep with the help of diagrams.</li>
  <li>Then we represented a diagram of how we can apply DFS for maze generation.</li>
  <li>Then we moved to the programming section, in this section, before starting the implementations, we learned how we can optimize the program.</li>
  <li>Then we implemented the actual program, starting with the smaller helper files and then with the most important file, that is the file responsible for rendering and generating mazes.</li>
</ul>
:ET