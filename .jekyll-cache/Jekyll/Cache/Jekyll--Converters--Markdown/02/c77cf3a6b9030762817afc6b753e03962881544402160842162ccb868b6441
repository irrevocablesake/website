I"Lƒ<h1 id="dfs-gradient-themed-maze-generator">DFS Gradient Themed Maze Generator</h1>
<hr class="separator" />

<p><img class="bigImage" src="/assets/images/series/maze-generator/ep1/main_gif.gif" /></p>

<p>Mazes, mazes, and mazes they are fun to solve, easy but require attention and patience, and more than that they are a good way of passing time. You can draw one right now, but it‚Äôs going to take a few minutes.</p>

<p>Today, we are going to learn how to automate the process of maze generation, we will learn to design an algorithm called ‚Äú<strong>DFS Backtracking</strong>‚Äù, lots of fancy terms in there, which is quite simple but generates pretty mazes, the visualization is fun to look at too and we will also look under the hood of the algorithm to get a good grasp on it‚Äôs working.</p>

<p>We will be designing an application in <strong>C++</strong> and <strong>Sfml</strong>, with tons of customizable features like number of rows, cols, cell size, colors etc. And we will also learn an interesting way to present those plain black border on white background mazes to something more lively like a <strong>Gradient Maze</strong>. So, without any further ado, Let‚Äôs Go!</p>

<p>This tutorial is going to be divided into three sections :</p>

<ul>
  <li>
    <p><b>Analogy</b> : In this section, we try to understand this entire maze generation / DFS algorithm thingy, through a real life example.</p>
  </li>
  <li>
    <p><b>Intuition</b> : In this section, we try to understand the working of dfs algorithm through diagrams</p>
  </li>
  <li>
    <p><b>Programming</b> : In this section, we try to program the maze generator program</p>
  </li>
</ul>

<p>Feel free to skip around!</p>

<p><i><b>Author‚Äôs Note : </b>Many people would say that there are better algorithms out there for generating mazes, and yes it‚Äôs true. But I treated this as a learning opportunity, and even to come to a conclusion that why other algorithms perform better than this, one should know what this algorithm does, that makes it un worthy! of using it in different situations.</i></p>

<p>Hope you enjoy the read!</p>

<h2 id="analogy">Analogy</h2>
<hr class="separator" />

<p>Before we actually start with all of that Mathyy / Programmingy intensive stuff, let‚Äôs try to get an analogy in here.</p>

<p>‚Äù <em>Imagine that you are in a maze, you are exactly at the start of the maze and want to reach the end of the maze. Since, you don‚Äôt know the structure of the maze, chances are that you are randomly going to choose a path and follow it. And if that path leads you to a dead end instead of just standing there, you might just retrace your steps back up to last intersection that you encountered. And if this intersection has any paths that you haven‚Äôt visited yet, you would visit those, if they help you reach the end point then well and good else you just return back to the intersection. Once you have tried out all of the possible paths from this intersection, only to find out that none of these lead to the exit of the maze, chances are you would move back from this intersection to an intersection before this, that you had already transversed path. Then, since you know that none of the paths ahead of the first intersection lead to the end point, you would never visit it again.</em> ‚Äú</p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/hit_dead_end.png" /></div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/retraced_dead_end.png" /></div>
</div>

<p><br style="clear:both" /></p>

<p>If we restate the above analogy in a slightly more computeristic language we would get something like this, a program made for solving mazes would start at a position, and every time it moves to a certain maze cell, it would mark it as visited and store it in the memory, but just in case if the path it is following leads to a dead end it will just retrace the maze cells, stored in it‚Äôs memory, and remove them from its memory, until it finds the last intersection it encountered, in its already transversed path, and if at that intersection, there is any path that it has not transversed yet then it would follow that path, else it would return to the intersection before this one and do the same thing, until if finds the solution.</p>

<p>And this is exactly the basis of two algorithms called <strong>DFS - Depth First Search</strong> and <strong>Backtracking</strong>. In the next sections, we will have a look at the algorithms.</p>

<h2 id="algorithms">Algorithms</h2>
<hr class="separator" />

<h3 id="backtracking">Backtracking</h3>

<p>Backtracking is a generalised method in which one can find many or some of the possible solutions for a certain problem. It works by building up solutions that might lead to our final answer and if at any stage it finds that a certain solution won‚Äôt lead to a final answer then it abandons it.</p>

<p>For a moment, if we just go back to our analogy, we can see that if a person decides to follow a certain path, given that it might or might not lead to the exit of the maze, this tells use that he was trying to build solutions to a problem, the problem being the solving of the maze, and the solution being a path from the start point to the end point. If at any point he hit a dead end he would just retrace his steps and get to a point which would lead him to a new path, which means that he abandoned / exhausted one of the many possible solutions by trying them out.</p>

<h3 id="depth-first-search-aka-dfs">Depth First Search a.k.a DFS</h3>

<p>Depth First Search is method which is largely related to tree and graph data structures. It is a kind of transversal method where one starts at a parent node goes down through the vertices / children nodes until it hits a dead end, once it hits a dead end it starts retracing back up to point where it finds that a certain node in its already transversed path has other unvisited nodes.</p>

<h4 id="what-is-the-difference-between-dfs-and-backtracking">What is the difference between DFS and Backtracking?</h4>

<p>Backtracking is more like a generalised case of DFS, which works out by ruling out the situations that won‚Äôt yield a result.</p>

<p>Let‚Äôs imagine this difference in terms of solving Sudoku grids. DFS in this case would be like a crazy maniac who would keep filling all of the squares completely and at the end if it does not find the solution, then it would discard it entirely and start with some other solution.</p>

<p>While Backtracking would work smartly by placing some constraint in place, like at each stage, when it fills a number, it would check if it‚Äôs a valid move, if it is then, it will move on to the next unfilled cell but if it‚Äôs not then it would discard that solution, since that wont lead the answer.</p>

<p>In a nut shell backtracking works by placing some constraints in place and not working like a crazy maniac.</p>

<h4 id="why-are-we-discussion-maze-solving">Why are we discussion maze solving?</h4>

<p>Well, it turn‚Äôs out the way dfs works, it can be used for both solving and creating mazes, the only difference being that instead of having a pre-made maze, we would start with a grid full of cells and borders, and then everytime we move from one cell to another we just erase the walls between the two cells, let‚Äôs not get too ahead of our selves, we will have a look at this afterwards.</p>

<h4 id="maze-generation-algorithm">Maze Generation algorithm</h4>

<p>This is the algorithm that can be found on wikipedia for maze generation :</p>

<ul>
  <li>
    <p>Choose the initial cell, mark it as visited and push it to the stack</p>
  </li>
  <li>
    <p>While the stack is not empty</p>

    <ul>
      <li>
        <p>Pop a cell from the stack and make it a current cell</p>
      </li>
      <li>
        <p>If the current cell has any neighbours which have not been visited</p>

        <ul>
          <li>
            <p>Push the current cell to the stack</p>
          </li>
          <li>
            <p>Choose one of the unvisited neighbours</p>
          </li>
          <li>
            <p>Remove the wall between the current cell and the chosen cell</p>
          </li>
          <li>
            <p>Mark the chosen cell as visited and push it to the stack</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>One might think that, why are we studying dfs or backtracking, if we already have an algorithm. Well, it turns out that Maze Generation is one of the many applications of the DFS. So, in order to understand the application we need to get a good grasp on the main algorithm itself.</p>

<h2 id="intuition">Intuition</h2>
<hr class="separator" />

<p>Now that we know what DFS and Backtracking are, let‚Äôs try to build a small intuition for their working as to how they work and transverse through a graph / tree. And then we will see how we can use the same thing for producing mazes.</p>

<h3 id="assumptions">Assumptions</h3>

<p>Before we actually start with the explanations, to make things easier let‚Äôs place a few assumptions in place :</p>

<ul>
  <li>
    <p>If we carefully look at the maze we can say that a maze can be easily represented as a graph were every maze cell would be an equivalent to graph node.</p>
  </li>
  <li>
    <p>We also assume that the dimensions of the maze are of 3x3.</p>
  </li>
  <li>
    <p>To actually remember the path, we are going to store it into a stack, we choose a stack cause it‚Äôs mechanism makes it earier for us to retrace back.</p>
  </li>
  <li>
    <p>We also assume that the graph is un-weighted.</p>
  </li>
</ul>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/labelled.png" /></div>
<div class="rightText"><p><b>Step 1</b><br /><br />Just to get familiar with graphs, here is a simple 3x3 graph with the nodes represented as grey colored boxes and each nodes is connected to some other node using blue lines also called <b>Edges</b><br /><br />We are also going to represent different states of nodes using colours<br />
<ul>
    <li><b>non visited node</b> : colourless</li>
    <li><b>visited node</b> : green color</li>
    <li><b>current node</b> : orange color</li>
    <li><b>possible neighbours</b> : blue color</li>
</ul>
</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide1.png" /></div>
<div class="leftText"><p><b>Step 2</b><br /><br />This is the initial state of the graph were we haven't visited any of the nodes yet.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide2.png" /></div>
<div class="rightText"><p><b>Step 3</b><br /><br />We start our journey of transversal at the top left corner of the graph, we mark the node 1 as visited, push it to the stack, and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide3.png" /></div>
<div class="leftText"><p><b>Step 4</b><br /><br />Now it's time to choose the next node, our current node has two possible neighbours, those are node 2 and node 4, which are represented by blue color. We can choose any one of the possible neighbours randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide4.png" /></div>
<div class="rightText"><p><b>Step 5</b><br /><br />We chose the node 2 as the next node, so we move from node 1 to node 2, and hence marking the node 2 visited and making it our current cell</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide5.png" /></div>
<div class="leftText"><p><b>Step 6</b><br /><br />Now we are currently at node 2, we check the possible neighbours that the node 2 has. The node 2 has two possible neighbours, node 3 and node 5. We can choose any one of those neighbours randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide6.png" /></div>
<div class="rightText"><p><b>Step 7</b><br /><br />Here we just randomly chose node 5 as our next node and hence we marked it as visited, pushed it to stack and made it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide7.png" /></div>
<div class="leftText"><p><b>Step 8</b><br /><br />Here we check the possible neighbours for the node 5, our current node, and it has 3 possible neighbours, node 6, node 4, node 8. We can choose any one of the possible neighbours randomly.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide8.png" /></div>
<div class="rightText"><p><b>Step 9</b><br /><br />We chose the node 8 as the next node, and hence we marked it as visited, pushed it to the stack and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide9.png" /></div>
<div class="leftText"><p><b>Step 10</b><br /><br />Here we check the possible neighbours for the node 8, it has 2 possible neighbours, node 9 and node 7.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide10.png" /></div>
<div class="rightText"><p><b>Step 11</b><br /><br />We randomly choose the node 7 as the next node and we marked it as visited, pushed it to the stack and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide11.png" /></div>
<div class="leftText"><p><b>Step 12</b><br /><br />We check the possible neighbours for node 7 and it turns out that it has only one neighbour node, node 4.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide12.png" /></div>
<div class="rightText"><p><b>Step 13</b><br /><br />Since we don't have any other option we chose the node 4, marked it as visited, pushed it to stack and made it our current node.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide13.png" /></div>
<div class="leftText"><p><b>Step 14</b><br /><br />Now, here is the thing, we were previously at the node 4 which had no possible neighbours, cause all of it's possible neighbours were visited, which is kind of like a dead end, with the context of our analogy, so we just retrace our steps back until we find a node / intersection which has a set of unvisited nodes and that is why we move back to node 7</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide14.png" /></div>
<div class="rightText"><p><b>Step 15</b><br /><br />We do the same thing at node 7, since even node 7 does not has any unvisited neighbours, we keep retracing back and we move to node 8.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide15.png" /></div>
<div class="leftText"><p><b>Step 16</b>We check the possible neighbours for node 8 and it has 1 possible node that is node 9 that has not been visited yet.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide16.png" /></div>
<div class="rightText"><p><b>Step 17</b>In this step we move to that one possible node, node 9, mark it as visited, push it to the stack and make it our current cell</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide17.png" /></div>
<div class="leftText"><p><b>Step 18</b>We check the possible neighbours for the node 6 and it turns out that this node has one possible neigbour.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide18.png" /></div>
<div class="rightText"><p><b>Step 19</b>We move to that one possible neighbour, push it to the stack, mark it as visited and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide19.png" /></div>
<div class="leftText"><p><b>Step 20</b>We check the possible neighbours for the current cell and it turns our this node has only one possible neighbour cell and that is node 3.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide20.png" /></div>
<div class="rightText"><p><b>Step 21</b>We mark the only neigbour that is node 3 as visited, push it to the stack and make it our current cell.</p></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide21.png" /></div>
<div class="leftText"><p><b>Step 21</b>We could technically stop here, since we have transversed all over the maze, but we don't keep a countt of the visited nodes, so what the maze-geenration algorithm will do is it will automatically pop all of the pushed nodes, and eventually making it empty.</p></div>
</div>

<p><br style="clear:both" /></p>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/slide22.png" /></div>
<div class="rightText"><p><b>Step 21</b>And this is the final result. We have visited all of the nodes.</p></div>
</div>

<p><br style="clear:both" /></p>

<p>Now some of you might question, how would this generate a maze, and the answer to the question is, that every time we move from one node to the other we remove the walls between the two nodes, doing this for every node change should eventually result in a maze.</p>

<p><br style="clear:both" /></p>
<div>
<div class="leftImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_1.png" /></div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_2.png" /></div>
</div>

<p><br style="clear:both" /></p>

<div>
<div class="rightImage"><img class="bigImage" src="/assets/images/series/maze-generator/ep1/dfs_intuition/grid_3.png" /></div>
<div class="leftText"><p>This is the final result of transversing through the grid using DFS algorithm and every time we move from a node to some other node we remove the walls between the two nodes.</p></div>
</div>

<p><br style="clear:both" /></p>
<h2 id="programming">Programming</h2>
<hr class="separator" />

<h3 id="optimizations">Optimizations</h3>

<p>We can immedietly think that since a maze is two dimensional object, that is, a grid and the grid has cells, and all of those cells have similar properties like, if the cell has been visited or not, the list of walls that the cells has, and the coordinates of the cell that we are currently working with, and one might suggest that we can create a <code>class Cell</code> and then create a two dimensional array out of the cell class.</p>

<p>So we would end up with a class something like this:</p>

<pre><code class="language-cpp">class Cell
{
  	public:
    	int x;
    	int y;
    	
    	bool visited;
    
    	bool walls={true,true,true,true};
};</code></pre>

<p>This looks great!</p>

<p>But this is not at all memory efficient, let‚Äôs just throw some numbers in here, to factualize why!, So for a second let‚Äôs imagine that we want to produce a 10k x 10k grid which means the total cells are around : <b>100000000</b>, and we can then create a 2d grid of out of the cell class like this:</p>
<pre><code class="language-cpp">Cell maze[10000][10000];</code></pre>
<p>and if we calculate memory required for one cell object that will around : 4 bytes + 4 bytes + 1 byte + 4 bytes, so in total that is around <b>13 bytes</b> for a single cell and for <b>100000000</b> cells it would be around : <b>1300000000</b> or <b>1.3 gb</b> and that is a tonn.</p>

<p>So we need to find a way to reduce the memory consumption for a single cell, which should reduce the overall memory consumption, and this is where  the concept of <b>Bits</b> and <b>Bit masking</b> is extremely useful.</p>

<h4 id="bits">Bits</h4>

<p>A <b>Bit</b> is the smallest unit in the computer world, a single bit can attain only two values either ‚Äú<b>1</b>‚Äù or ‚Äú<b>0</b>‚Äù. If a bit is said to be ‚Äú<b>ON</b>‚Äù then the bit has a value of ‚Äú<b>1</b>‚Äù and if a bit is said to be ‚Äú<b>OFF</b>‚Äù then it is said to have a value of ‚Äú<b>0</b>‚Äù.</p>

<p>Of course just having sequences of tons of bits is no fun, so to be able to perform operations between different bits we have something called <b>Bitwise Operators</b>.</p>

<h5 id="bitwise-operators-and-operation">Bitwise Operators and Operation</h5>

<p>Bitwise operators are used to play with bits, that is, if we provide it a decimal number, that is a human readable value, it‚Äôs gonna take that number and play around with its bits, sounds fun.</p>

<p>We have 6 different bitwise operators, luckily they work exactly like the logical operators.</p>

<pre><code class="language-cpp">&amp;  : This works like the logical AND
|  : This works like the logical OR 
~  : This works like the logical NOT
^  : This works like the logical XOR
&lt;&lt; : This bitwise operator shifts the bits to the left by a certain positions.
&gt;&gt; : This bitwise operator shifts the bits to the right by a certain positions.</code></pre>
<p>and using these bitwise operators we can do tons of useful stuff and optimizations.</p>

<p><b>Note : </b>The number of bits that we get to play around depends upon the size of data type, that is, a <b>char</b> being <b>1 byte</b>, it‚Äôs gonna provide us with <b>8 bits</b> to play around, <b>int</b> being <b>4 bytes</b>, it‚Äôs gonna provide us with <b>32 bits</b> to play around.</p>

<p>The thing is computers do not understand any of this, they are just good at following orders.</p>

<p>Using the bitwise operators is gonna affect the entire sequence of bits, but what if we want to work with a certain bit at a certain position in that sequence of bits. This is where the concept of ‚Äú<b>Bit Masking</b>‚Äù comes in.</p>

<h5 id="bit-masking">Bit Masking</h5>

<p>Just as the name says it works by <b>masking</b> / <b>hiding the bits</b> that we do not wanna work with and <b>exposing</b> only the ones that we wanna work with. Using bit masks, with the combination of logical operators, would allow us to change the values of the bits, also help us check if a certain bit is ‚Äú<b>ON</b>‚Äù or ‚Äú<b>OFF</b>‚Äù.</p>

<p>A bit mask generally has the following structure, assuming we are talking about <b>8 bits</b>.</p>

<pre><code class="language-cpp">00000001 // we refer to this as the mask</code></pre>
<p>were the bit set to ‚Äú<b>1</b>‚Äù says that ‚Äú <i>hey this is the position we wanna work with</i> ‚Äú meaning it kinda exposes that value to changes and the bits set to ‚Äú<b>0</b>‚Äù kinda masks the values, so none of the changes are applied to it.</p>

<p>To check if a bit is on or off :</p>
<pre><code class="language-cpp">mask = 10000000
value = 11110001

mask &amp; value // this means we want to check if the last bit of the value is set to one or not if it's on then it return 1 else 0, meaning it just performs and operation between the values</code></pre>
<p>To turn a bit on:</p>
<pre><code class="language-cpp">mask = 10000000
value = 00000011

value |= mask // this would perform "OR" operation between the two and store the result into the value.

value = 10000011
</code></pre>
<p>To turn a bit off:</p>
<pre><code class="language-cpp">mask = 10000000
value = 10000101

value &amp;= ~mask; // here we first invert the value of mask so the bits of mask become 01111111 and then we apply the &amp; operator to the value and the inverted mask

value = 00000101</code></pre>

<h3 id="back-to-optimization">Back to Optimization</h3>

<p>Now that we know what <b>Bits</b>, <b>Bits Masks</b> are, and how we can work on a bit level, let‚Äôs start with the optimization procedure.</p>

<p>Let‚Äôs start with the fact that we do not really need to store the coordinates of the cell, we can just find out the neighbouring cells based on the index of the current cell, and since we are using arrays, we already will be having the index of the current cell. Eliminating the co-ordinates would reduce around <b>8 bytes</b>.</p>

<p>Let‚Äôs have a look the walls since the walls can attain only two values either ‚Äú<b>0</b>‚Äù or ‚Äú<b>1</b>‚Äù, we can directly store them inside a byte as contigious bits and that goes same with the visited parameter, since that too can attain only two values we can also store that with the wall bits.</p>

<p>As we read above the number of bits that we get to play with are decided by the data type and since we only need around <b>5 bits</b> we can choose the smallest data type, that is the ‚Äú<b>unsigned char</b>‚Äù. This would give us around <b>8 bits</b> to play around, which is more than enough we will only use <b>5 bits</b> per cell for storing the properties.</p>

<p>so something like this</p>

<pre><code class="language-cpp">//One can come up with any convention of storing the 5 bits in the unsigned char, we choose the following convention

// unsigned char cell = 0b000V'LBRT
// where the V stands for the visited bit
// and L,B,R,T stand for LEFT, BOTTOM, RIGHT, TOP wall existance bits, respectively

unsigned char cell = 0b0000'1111</code></pre>

<p>Now we can just save the state of a particular cell in under 1 byte.</p>

<p>If it‚Äôs just a single variable using a class for storing the it would be overkill, cause we can directly create an array out of a single variable.</p>

<p>something like this:</p>
<pre><code class="language-cpp">unsigned char cell[10000][10000];</code></pre>
<p>let‚Äôs calculate the memory usage for this, so <b>100000000</b> cells <b>1 byte</b> each equals to <b>100000000 bytes</b> which is <b>100mb</b> which is a lot lot better than the <b>1.3 gb</b> memory usage.</p>

<p>There is another optimization we can do, and that is related to the representation of the maze</p>

<h5 id="representation">Representation</h5>
<p>We want a grid to work with and that can be done using <b>static</b> 2d array / multi dimensional array but since static array have scope limitations, we need to use <b>dynamic 2d array</b>. But doing this would cause a lot of <b>fragmented memory</b>, which is bad cause it‚Äôs going to affect the efficiency of our program, cause every new row of the grid would be located at a new location, and to overcome this we can use a <b>dynamic 1d array</b>, we will represent a 2d grid into 1d array :</p>

<pre><code class="language-cpp">
0  1  2  3       
4  5  6  7
8  9  10 11

// normally grid cell can be located by saying that's it's in a particular row and column
//for instance let's say we want to locate element 6, we can say that its in row 1 and column 2

But if we start counting from the first cell till the last cell and assign numbers, just like in the above diagram we can use indexes to locate a cell.

Likewise we can just store the 2d grid as a 1d array by rearraging the original 2d array

0 1 2 3 4 5 6 7 .......11

// we can see here that the index of the first element in the second row is a continuation of the index of the last element of the first row
// if you want to access a particular cell based upon the row and column
//then one can just use the following formula : row * (number of cols) + col
// the index of element 6 in the 1d array would be : 1 * 4 + 2 = 6
// which means that the element 6 is at 6th position in the 1d array. 
</code></pre>
<p>This would give us a few advantages too like caching of memory and a more compact memory and hence a faster program.</p>

<p>This should be enough optimizations for the program and we can start now.</p>

<h4 id="file-structure">File Structure</h4>
<p>We are gonna be using the following file strucutre</p>
<pre><code class="language-cpp">//********************Helper****************************
helper.h   
helper.cpp
// generation of random numbers
//*******************************************************

//**************************Masking******************************
masking.h
// holds all of the masks for working with bits
//***************************************************************

//**************************Image Saving**************************
image.h
image.cpp
// contains a function that helps us with the saving of image
//****************************************************************

//**************************Features File*************************    
feature.h
// this file will act as a data holder for all of the features of the maze
//****************************************************************

//**************************Maze**********************************
maze.h
maze.cpp
// this file act as the heart of the program, DFS + Graphics
//****************************************************************
</code></pre>

<h4 id="implementation">Implementation</h4>

<p>Let‚Äôs start with the helper file, the sole purpose of this file is going to be able to help us generate random numbers. The structure of the header file is going to be something like this</p>

<pre><code class="language-cpp">class Helper
{
    struct xorshift128p_state
    {
        uint64_t a, b;
    };
    
    public :
        Helper();
        xorshift128p_state state;
        uint64_t xorshift128p(struct xorshift128p_state *state);
};</code></pre>

<p>and the corresponding file for all of the method bodies is going to be something like this :</p>

<pre><code class="language-cpp">Helper::Helper()
{
	srand(time(NULL));
	state.a=rand();
	state.b=rand();
}

uint64_t Helper::xorshift128p(struct xorshift128p_state *state)
{
	uint64_t t = state-&gt;a;
	uint64_t const s = state-&gt;b;
	state-&gt;a = s;
	t ^= t &lt;&lt; 23;		// a
	t ^= t &gt;&gt; 17;		// b
	t ^= s ^ (s &gt;&gt; 26);	// c
	state-&gt;b = t;
	return (t + s);
}</code></pre>

<p>The way this file works is that as soon as we create an <b>object</b> of the class Helper, it calls the <b>constructor</b> which then randomizes the states / input values of random number generator. Then every time we want to generate a random number, we just have to call the xorshift128p() and we just have to pass those states to that function, then that function generates a random value based upon the passed states / input values, with the help of bitwise operations, and it updates old state with new values.</p>

<p>So, in a nut shell this works by producing random values based upon states, and since using the same states would produce same random number, it just re-populates the old states with somekind of new value and uses those new states for producing another new random number, this updation of states occcurs every time we call the xorshift128p().</p>

<p>Now let‚Äôs start with another file called <b>Features</b> file. The sole puporse of this file is going to be holding all of the necessary data regarding the <b>dimensions and apperance</b> of the maze, so just in case if we need to use the data regarding anything related to <b>dimensions / appearance</b>, we will be able to access it in one place.</p>

<h5 id="features-file">Features file</h5>

<pre><code class="language-cpp">struct Feature
{
    int width;
    int height;
    int rows;
    int cols;
    int cellSize;
    int fps;
    int animate;

    sf::Color borderColor;
    sf::Color backgroundColor;
    sf::Color start;
    sf::Color end;
    sf::Color visitedColor;
    sf::Color notVisitedColor;
    sf::Color currentColor;
};</code></pre>

<p>To use this, we just have to declare an object of this structure and then we can access the various properties, just like in the following example</p>

<pre><code class="language-cpp">Feature feature;
feature.width=500;
feature.height=500;
.
.
.</code></pre>

<p>As mentioned in the above <b>optimization sections</b>, working at a bit level is going to help us make our application effiecient. So we are going to use all of the concepts that we discussed in the said section.</p>

<p>We are going to create a file called masking which will hold all of the data related to the masks for using them with bits.</p>

<pre><code class="language-cpp">const unsigned char topMask = 0b0000'0001;
const unsigned char rightMask = 0b0000'0010;
const unsigned char bottomMask = 0b0000'0100;
const unsigned char leftMask = 0b0000'1000;
const unsigned char visitedMask = 0b0001'0000;</code></pre>

<p>We are also going to create a file called image, that will help us with the saving of image, given that we pass it the array of type <b>unsigned char</b> with binary values. But since this tutorial is about maze generation and not about maze saving, we are not going to discuss it here, but you can find the code for the funtion on the github.</p>

<p>Now, it‚Äôs time to create the most important file, that is in fact the <b>heart</b> of the program.</p>

<p>This file is divided into 4 sections :</p>
<ul>
  <li>The first section sets the user defined features to the maze.</li>
  <li>The second section uses DFS algorithm to generate mazes.</li>
  <li>The third section generates the graphics, if needed.</li>
  <li>The fourth section acts as a control for calling various functions.</li>
</ul>

<p>Something like this :</p>

<pre><code class="language-cpp">class Maze
{
    private:
        vector&lt;unsigned char&gt; maze;
        vector&lt;int&gt; backtrack;

        Feature f;
        Helper helper;
        Image image;
        
    public:
        void setFeatures(const Feature &amp;feature); // this functions sets the user defined features to the maze
        void createMaze(string windowName);
   
    private:  
       
        //******************************DFS Section******************************
        void checkNeighbour(int current);
        void dfsBacktrack();
        //***********************************************************************

        //******************************Graphics Section*************************
        void drawWindow(sf::RenderWindow &amp;window, string windowName);
        void handleBorder(int borderCounter,int x,int y,int value);
        void createVertexArray(int explicitCheck=-1);
        //***********************************************************************

        //******************************Image Saving*****************************
        void saveAsImage();
        //***********************************************************************

        //******************************Main Control*****************************
        void initialize(); // + createMaze(string windowName)
        //***********************************************************************
};</code></pre>

<p>The first function here that will be called is the <mark>setFeatures()</mark>, this function would receive the feature object that the <b>user</b> has <b>populated</b> and it will set the features to the maze.</p>

<pre><code class="language-cpp">void Maze::setFeatures(const Feature &amp;feature)
{
    f=feature;
    f.rows=f.height/f.cellSize;
    f.cols=f.width/f.cellSize;
}</code></pre>

<p>Then the next function that the user will call is the <code>createMaze()</code></p>

<pre><code class="language-cpp">void Maze::createMaze(string windowName)
{
    initialize();

    maze[0] |= visitedMask; // we marked it as visited by turning the visited bit on using bitwise operators
    backtrack.push_back(0);

    externalLimit=(f.rows*f.cols)-1;

    if(f.animate==-1)
    {   
        dfsBacktrack(); 
        image.saveImage("love_testing.png",maze,f);
    }
    else if(f.animate==0)
    {
        sf::RenderWindow window;
        dfsBacktrack();
        createVertexArray(1);
        drawWindow(window,windowName);
        image.saveImage("love_testing.png",maze,f);
    }
    else if(f.animate==1)
    {
        sf::RenderWindow window;
        createVertexArray(1);
        drawWindow(window,windowName);
        image.saveImage("love_testing.png",maze,f);
    }

    maze.clear();
    vector&lt;unsigned char&gt;().swap(maze);
}</code></pre>

<p>This function would then in turn called another function called <code>initialiaze()</code>, this initialize function would then resize all of the necessary containers.</p>

<pre><code class="language-cpp"> try 
{
    unsigned char initial=0b0000'1111;
    maze.resize(f.rows*f.cols,initial); // this is the maze data holder
}
catch (const std::bad_alloc&amp;)
{
    cout&lt;&lt;"error in initializing the array";
}

if(f.animate!=-1)
{
    quad.setPrimitiveType(sf::Quads);   // this is related to graphics
    border.setPrimitiveType(sf::Lines); // this is related to graphics

    quad.resize(4*f.rows*f.cols);       // this is related to graphics
    border.resize(8*f.rows*f.cols);     // this is related to graphics
}</code></pre>

<p>Once the <code>initialize()</code> is done executing, we resume the createMaze(), it then marks a starting point for transversal, here we choose the first cell as the starting point using the following statements</p>

<pre><code class="language-cpp">maze[0] |= visitedMask;
backtrack.push_back(0);</code></pre>

<p>Now let‚Äôs talk about the dfs fucntion(), we‚Äôll have a look at the various modes later.</p>

<pre><code class="language-cpp">void Maze::dfsBacktrack()
{
    if(f.animate!=1)
    {
        int current;
         
        while(!backtrack.empty())
        {
            current=backtrack.back();
            backtrack.pop_back();
           
            checkNeighbour(current);
        
        }
    }
    else if(f.animate==1 &amp;&amp; !backtrack.empty())
    {
        int current=backtrack.back();
        backtrack.pop_back();

        checkNeighbour(current);
    }
}</code></pre>

<p>This function first checks what mode is currently set, if it‚Äôs not visualization, it just performs the entire dfs algorithm in one step and updates the maze data holder accordingly. At each step of the algorithm it checks if the stack, that it is using, to store the transversed path, is empty or not, if it is emtpy it just stops the operation, else if it‚Äôs not it pops the last pushed node and passes it to the check neighbour function.</p>

<p>The checkNeighbour(), then check if the passed node has any neighbour that has not been visited yet, if it does then it makes a list of all such neighbours and chooses a random neighbour and pushes the current node back to the stack and the next randomly choosen neighbour. If it does not find any neighbour then it just does nothing.</p>

<p>Let‚Äôs pause here for a second and have a look how it smartly retraces back. If the current node does not has any neighbour then it should be be autmatically removed from the stack and the previous node should be examined, just as we saw in the intuition, and this is exactly what the function does, it before calling the function it first pops the current node and only pushes it back if it has any unvisited nodes else it does not, which is kind of like a automatic backtracking.</p>

<p>and this is how the mode -1 works, the it calls the dfs() and since the mode is set to -1, which means it‚Äôs not visualization, it performs the entire dfs algorithm in one step and then we call and pass the maze, data holder, to the imagesave(), which then proceeds to save the image as a png file.</p>

<p>Now let‚Äôs talk about mode 0, this one works exactly like mode -1, except for the fact that we also need to display the maze graphically on the screen. So, in this case we just call two extra fucntions called createVertexArray() and drawWindow(), what these functions do is first the createvertexarray() converts the vector data, that is the final maze generated by the dfs algorithm, to graphical data through vertexArray and that drawWindow() keeps drawing the created vertexArray on the screen.</p>

<pre><code class="language-cpp">void Maze::createVertexArray(int explicitCheck)
{
    if(explicitCheck==1)
    {
        for(int i=0;i&lt;f.rows;i++)
        {
            for(int j=0;j&lt;f.cols;j++)
            {
                firstCalcx=(j*f.cellSize)+padding;
                firstCalcy=(i*f.cellSize)+f.cellSize+padding;
                secondCalcx=j*f.cellSize+padding;
                secondCalcy=i*f.cellSize+padding;
                thirdCalcx=(j*f.cellSize)+f.cellSize+padding;
              
                quad[counter].position.x=firstCalcx;
                quad[counter].position.y=firstCalcy;
                ..

                border[borderCounter].position.x=secondCalcx;
                border[borderCounter].position.y=secondCalcy;
                ..

                int visited=maze[(f.cols*i)+j] &amp; visitedMask;
                if(!visited)
                {   
                    quad[counter].color = f.notVisitedColor;
                    quad[counter+1].color = f.notVisitedColor;
                    quad[counter+2].color =f.notVisitedColor;
                    quad[counter+3].color =f.notVisitedColor;
                }
                else
                {
                   
                    quadColor.r=(f.start.r*p)+(f.end.r*(1-p));
                    quadColor.g=(f.start.g*p)+(f.end.g*(1-p));
                    quadColor.b=(f.start.b*p)+(f.end.b*(1-p));

                    quad[counter].color = quadColor;
                    quad[counter+1].color = quadColor;
                    quad[counter+2].color = quadColor;
                    quad[counter+3].color =quadColor;
                }
  
                handleBorder(borderCounter,i,j,-1);
            
                counter=counter+4;
                borderCounter=borderCounter+8;
            }
            p=p-((initial/f.rows));
        }
    }
    else
    {
        if(!backtrack.empty())
        {
            float first=initial-(int(backtrack.back()/f.cols)) * (initial/f.rows);
            float second=1 - first;
 
            quadColor.r=(f.start.r*first)+(f.end.r*second);
            quadColor.g=(f.start.g*first)+(f.end.g*second);
            quadColor.b=(f.start.b*first)+(f.end.b*second);

            quad[(backtrack.back()*4)].color = quadColor;
            quad[(backtrack.back()*4)+1].color = quadColor;
            quad[(backtrack.back()*4)+2].color = quadColor;
            quad[(backtrack.back()*4)+3].color =quadColor;

            if(backtrack.size()&gt;=2)
            {
                handleBorder((backtrack.back()*8),-1,-1,backtrack.back());            
                handleBorder((backtrack[(backtrack.size()-2)]*8),-1,-1,backtrack[(backtrack.size()-2)]);            
            }
        }
    }
}</code></pre>

<p>This function loops through every cell of the maze and converts all of the mathematical data to  something that is graphical and it also check if the cell is visited or not, if it is then it paints it with the user defined color else it paints with a mathemcatially generated gradient between two colors specified by the user, we will talk about this gradient thingy in a few minutes, the other thing it does that for each cell it invokes a function called handleborder, this function checks which of the border exists and which of them dont and it paints the border with user specified border color and transparent color respectively.</p>

<p>This is the handleborder()</p>

<pre><code class="language-cpp">void Maze::handleBorder(int borderCounter,int x,int y,int value)
{
    int index;
    if(value&lt;0)
    {
        index=(f.cols*x)+y;
    }
    else
    {
        index=value;
    }
    
    if(maze[index] &amp; topMask)
    {
        border[borderCounter].color = f.borderColor;
        border[borderCounter+1].color = f.borderColor;
    }
    else
    {
        border[borderCounter].color =sf::Color::Transparent;
        border[borderCounter+1].color =sf::Color::Transparent;
    }    
    if(maze[index] &amp; rightMask)
    {
        border[borderCounter+2].color = f.borderColor;
        border[borderCounter+3].color =f.borderColor;
    }
    else
    {
        border[borderCounter+2].color =sf::Color::Transparent;
        border[borderCounter+3].color = sf::Color::Transparent;
    }
    if(maze[index] &amp; bottomMask)
    {
        border[borderCounter+4].color = f.borderColor;
        border[borderCounter+5].color = f.borderColor;
    }
    else
    {
        border[borderCounter+4].color =sf::Color::Transparent;
        border[borderCounter+5].color = sf::Color::Transparent;
    }
    if(maze[index] &amp; leftMask)
    {
        border[borderCounter+6].color = f.borderColor;
        border[borderCounter+7].color = f.borderColor;
    }
    else
    {
        border[borderCounter+6].color = sf::Color::Transparent;
        border[borderCounter+7].color =sf::Color::Transparent;
    }
}</code></pre>

<p>and the drawWindow() looks like this:</p>

<pre><code class="language-cpp">void Maze::drawWindow(sf::RenderWindow &amp;window,string windowName)
{
      int padding=10;
      window.create(sf::VideoMode((f.cols*f.cellSize)+(2*padding),(f.rows*f.cellSize)+(2*padding)),windowName);
      
      if(f.animate)
      {
        window.setFramerateLimit(f.fps);
      }
      
      while(window.isOpen())
      {
          sf::Event event;
          while(window.pollEvent(event))
          {
              if(event.type==sf::Event::Closed)
              {
                  window.close();
              }
          }

          window.clear(f.backgroundColor);

            if(f.animate)
            {
                dfsBacktrack();
                createVertexArray(-1);
                if(!backtrack.empty())
                {
                    quad[(backtrack.back()*4)].color = f.currentColor;
                    quad[(backtrack.back()*4)+1].color = f.currentColor;
                    quad[(backtrack.back()*4)+2].color = f.currentColor;
                    quad[(backtrack.back()*4)+3].color =f.currentColor;
                }
            }        

            window.draw(quad);
            window.draw(border);

            window.display();

        if(f.animate &amp;&amp; !backtrack.empty())
        {
            quad[(backtrack.back()*4)].color = quadColor;
            quad[(backtrack.back()*4)+1].color = quadColor;
            quad[(backtrack.back()*4)+2].color = quadColor;
            quad[(backtrack.back()*4)+3].color =quadColor;
        }
      }
}</code></pre>

<p>It just creates a window and keeps running it until the user closes it, and for each frame it just keeps drawing the said vertex arrays as soon as the user hits the close button the said maze vector is passed to the saveimage function which then proceeds to save this mathematical data as an png image.</p>

<p>Now let‚Äôs move to the visualization mode, creating this mode is just a matter of adding a few if else statements, this works exactly like the mode 0, except for the fact that instead of performing the entire dfs in one step we do it per frame, meaning we call the dfs function every frame, which means the vectro maze is being updated every frame which means we also need to update the vertex data for each frame, which can be done by calling the dfs() and createVertexArray() for each frame.</p>

<p>But imagine this the first frame is going to be a grid full of cells, each having all of its walls, and then every frame we just either pop or push either a single cell, which meaning we don‚Äôt have to go through the entire maze and create a new vertex array, instead we can just update the only data that has been changed between the current and the last frame, and this can be dont easily by adding a if else statement in the vertex array and that is the solve purpose of if(explicitcheck==1) in the createVertexArray(), it checks if the mode is visualization or not if it is then it just updates the only data that has been changed between two frames else if it‚Äôs not it and the dfs() won‚Äôt even be called in the draw window(), since in the other two modes the dfs will be performed in one step and it will be just a matter of displaying it on the users screen.</p>

<p>and finally this is what the main control for the entire program would look like</p>

<pre><code class="language-cpp">int main()
{
    sf::Color grey(200,200,200);
    sf::Color start(209,59,19);
    sf::Color end(0,25,51);
    
    Feature feature;

    feature.animate=0;
    feature.fps=0;
    feature.width=500;
    feature.height=500;
    feature.cellSize=23;
    feature.backgroundColor=sf::Color::White;
    feature.borderColor=sf::Color::Black;
    feature.currentColor=sf::Color::Red;
    feature.notVisitedColor=grey;
    feature.start=sf::Color::White;
    feature.end=sf::Color::White;

    Maze maze;
    maze.setFeatures(feature);
    maze.createMaze("DFS Backtracking Maze");
  
    return 0;
}</code></pre>

<p>The user has just to populate the feature object and then set the features to the maze and start the process of maze generation through createMaze();</p>
:ET